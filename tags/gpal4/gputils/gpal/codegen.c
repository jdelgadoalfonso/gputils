/* code generation
   Copyright (C) 2003
   Craig Franklin

This file is part of gputils.

gputils is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

gputils is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with gputils; see the file COPYING.  If not, write to
the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */

#include "stdhdr.h"

#include "libgputils.h"
#include "gpal.h"
#include "codegen.h"
#include "codegen14.h"

#ifdef STDC_HEADERS
#include <stdarg.h>
#endif

/* prototypes */
static void write_statements(tree *statements);

/* FIXME: this function is common with gpasm/scan.l */

static char *
to_lower_case(char *name)
{
  char *new;
  char *ptr;

  ptr = new = strdup(name);

  while (*ptr != '\0') {
    *ptr = tolower(*ptr);
    ptr++;
  }

  return new;
}

void
add_global(char *name, char *alias, tree *object)
{
  struct symbol *sym;
  struct variable *var;

  sym = get_symbol(state.global, name);
  if (sym == NULL) {
    sym = add_symbol(state.global, name);
    var = malloc(sizeof(*var));
    annotate_symbol(sym, var);
    var->node = object;
    var->alias = to_lower_case(alias);
    var->is_constant = false;
    var->is_public = false;
    var->is_external = false;
    var->value = 0;
  } else {
    gp_error("duplicate symbol \"%s\"", name);
  }
  
  return;
}

void
add_constant(char *name, int value)
{
  struct symbol *sym;
  struct variable *var;

  sym = get_symbol(state.global, name);
  if (sym == NULL) {
    sym = add_symbol(state.global, name);
    var = malloc(sizeof(*var));
    annotate_symbol(sym, var);
    var->node = NULL;
    var->alias = NULL;
    var->is_constant = true;
    var->is_public = false;
    var->is_external = false;
    var->value = value;
  } else {
    gp_error("duplicate symbol \"%s\"", name);
  }
  
  return;
}

struct variable *
get_global(char *name)
{
  struct symbol *sym;
  struct variable *var = NULL;

  sym = get_symbol(state.global, name);
  if (sym == NULL) {
    gp_error("undefined symbol \"%s\"", name);
  } else {
    var = get_symbol_annotation(sym);
  }

  return var;
}

static void
write_header(void)
{
  char buffer[BUFSIZ];

  gp_date_string(buffer);

  fprintf(state.output.f, "; %s\n", state.asmfilename);
  fprintf(state.output.f, "; generated by gpal on %s\n\n", buffer);

  if (state.processor_chosen) {
    fprintf(state.output.f, "  processor %s\n", 
            state.processor_info->names[1]);
    fprintf(state.output.f, "  include \"%s.inc\"\n\n",
            state.processor_info->names[1]);
  } else {
    gp_error("processor not selected");
  } 

  return;
}

static void
write_startup(void)
{
  tree *current = NULL;
  tree *head;

  current = state.root;

  while (current != NULL) {
    if (current->tag == node_proc) {
      head = current->value.proc.head;
      assert(head != NULL);
      if (strcmp(head->value.head.name, "main") == 0) {
        /* a procedure named "main" exists so add the startup code */
        fprintf(state.output.f, "; startup and interrupt vectors\n");
        fprintf(state.output.f, "STARTUP code\n");
        fprintf(state.output.f, "  pagesel main\n");
        fprintf(state.output.f, "  goto main\n\n");
        break;     
      }
    }
    current = current->next;
  }

}

static void
write_footer(void)
{
  fprintf(state.output.f, "  end\n\n");
}

void 
write_asm_line(const char *format, ...)
{
  va_list args;
  char buffer[BUFSIZ]; 

  va_start(args, format);
  vsprintf(buffer, format, args);
  va_end(args);

  fprintf(state.output.f, "  %s\n", buffer);

  return;
}

static int label_number = 0;

char *
next_label(void)
{
  char label[BUFSIZ];
  sprintf(label, "_%i", label_number++);
  return strdup(label);
}

void
write_label(char *label)
{
  fprintf(state.output.f, "%s:\n", label);
}

static
int list_length(tree *L)
{
  if (L == NULL) {
    return 0;
  } else {
    return 1 + list_length(LIST_TAIL(L));
  }
}

static void
write_call(tree *statement)
{

  fprintf(state.output.f, ";#CSRC %s %d\n", 
          state.srcfilename,
          statement->line_number);

/*
  struct variable *var;

  var = get_global(statement->value.call.name);
  if (var == NULL)
    return;
*/

/*  if (statement->value.call.args) {
    call_length = list_length(statement->value.call.args);
  
  
  }
*/
  fprintf(state.output.f, "  pagesel %s\n", statement->value.call.name);
  fprintf(state.output.f, "  call %s\n", statement->value.call.name);

  return;
}

int temp_number;
int max_temp_number;

static void
write_expression(tree *statement)
{
  tree *lhs;
  tree *rhs;
  struct variable *var;
  char *lhs_name;

  fprintf(state.output.f, ";#CSRC %s %d\n", 
          state.srcfilename,
          statement->line_number);
  
  if ((statement->tag != node_binop) || 
      (statement->value.binop.op != op_eq)) {
    gp_error("invalid expression");
    return;
  }

  lhs = statement->value.binop.p0;
  rhs = statement->value.binop.p1;

  if (lhs->tag != node_symbol) {
    gp_error("invalid lvalue in assignment");
    return;
  }
  
  var = get_global(lhs->value.symbol);
  lhs_name = var->alias;

  temp_number = 0;
  gen_expr(rhs);

  if (var->is_constant) {
    if (var->is_equ) {
      /* This is an equate from the processor header file.  gpal doesn't
         get type information from that file.  It has to assume that 
         the constant is a register address */
      gen_put_reg(var->value);
    } else {
      gp_error("incorrect l-value \"%s\"", lhs->value.symbol);
    }  
  } else {
    gen_put_mem(lhs_name);
  }

  if (temp_number > max_temp_number)
    max_temp_number = temp_number;

}

static void
write_cond(tree *cond)
{
  char *end_label = NULL;

  /* else doesn't have a condition */
  if (cond->value.cond.cond != NULL) {
    end_label = next_label();
    fprintf(state.output.f, ";#CSRC %s %d\n", 
            state.srcfilename,
            cond->value.cond.cond->line_number);
    temp_number = 0;
    write_test(cond->value.cond.cond, end_label);
    if (temp_number > max_temp_number)
      max_temp_number = temp_number;
  }
  
  /* write the body of the code */
  write_statements(cond->value.cond.body);
  
  /* if there is a condition generate a label at the end of the body */
  if (cond->value.cond.cond != NULL) {
    write_label(end_label);
    if (end_label)
      free(end_label);
  }
  
  /* generate next conditional block, if there is one */
  if (cond->value.cond.next != NULL)
    write_cond(cond->value.cond.next);
}

static void
write_loop(tree *loop)
{
  char *start_label = NULL;

  /* write out initalization code */
  if (loop->value.loop.init != NULL) {
    write_statements(loop->value.loop.init);
  }
 
  start_label = next_label();
  write_label(start_label);

  /* write the body of the loop */
  if (loop->value.loop.body != NULL)
    write_statements(loop->value.loop.body);

  /* write the increment statements */
  if (loop->value.loop.incr != NULL)
    write_statements(loop->value.loop.incr);

  /* write the exit statements */
  if (loop->value.loop.exit != NULL) {
    fprintf(state.output.f, ";#CSRC %s %d\n", 
            state.srcfilename,
            loop->value.loop.exit->line_number);
    temp_number = 0;
    write_test(loop->value.loop.exit, start_label);
    if (temp_number > max_temp_number)
      max_temp_number = temp_number;
  } else {
    write_asm_line("goto %s", start_label);
  }

  if (start_label)
    free(start_label);
}

static void
write_statements(tree *statements)
{
  tree *list;
  tree *statement;

  list = statements;
  assert(list->tag == node_list);
  while(list) {
    statement = LIST_HEAD(list);
    switch(statement->tag) {
    case node_call:
      write_call(statement);
      break;
    case node_cond:
      write_cond(statement);  
      break;
    case node_loop:
      write_loop(statement);
      break; 
    default:
      write_expression(statement);
    }
    list = LIST_TAIL(list);
  }

}

static void
write_decl(tree *decl, char *name)
{
  tree *list;  
  tree *symbol;
  char alias[BUFSIZ];

  assert(decl->tag == node_decl);
  list = decl->value.decl.expr;
  assert(list->tag == node_list);

  for (; list; list = LIST_TAIL(list)) {
    symbol = LIST_HEAD(list);
    assert(symbol->tag == node_symbol);
    sprintf(alias, "%s_%s", name, symbol->value.symbol);
    add_global(symbol->value.symbol, alias, symbol);
    if (decl->value.decl.type == type_var) {
      fprintf(state.output.f, "%s res 1\n", alias);
    }
  }

}

static void
write_declarations(void)
{
  tree *current = NULL;
  int first_time = 1;
  tree *list;  
  tree *symbol;
  tree *lhs;
  tree *rhs;

  current = state.root;

  while (current != NULL) {
    if ((current->tag == node_decl) && 
        (current->value.decl.storage != storage_extern)) {
      if ((current->value.decl.type == type_const) &&
          (current->value.decl.storage != 0)) {
        gp_error("constants can't be public or volatile");
      } 
      /* FIXME: only bytes are supported so far */
      assert(current->value.decl.size == size_byte);
      if (first_time) {
        fprintf(state.output.f, "; declarations \n");
        fprintf(state.output.f, "  udata\n");
        first_time = 0;      
      }
      for (list = current->value.decl.expr; list; list = LIST_TAIL(list)) {
        symbol = LIST_HEAD(list);
        if (current->value.decl.type == type_var) {
          assert(symbol->tag == node_symbol);
          fprintf(state.output.f, "%s res 1\n", symbol->value.symbol);
          if (current->value.decl.storage == storage_public) {
            fprintf(state.output.f, "  global %s\n", symbol->value.symbol);
          }
          add_global(symbol->value.symbol, symbol->value.symbol, current);
        } else if (current->value.decl.type == type_const) {
          assert(symbol->tag == node_binop);
          lhs = symbol->value.binop.p0;
          assert(lhs->tag == node_symbol);
          rhs = symbol->value.binop.p1;
          assert(rhs->tag == node_constant);
          add_constant(lhs->value.symbol, rhs->value.constant);
        }
      }
    }
    current = current->next;
  }

  if (!first_time)
    fprintf(state.output.f, "\n");

}

static void
write_procedure(tree *procedure, int is_func)
{
  tree *head;
  tree *body;
  char *name;
  tree *args;
  tree *decl;
  tree *statements;
  tree *argument;
  int i;
  int storage;

  if (is_func) {
    head = procedure->value.func.head;
    storage = procedure->value.func.storage;
    body = procedure->value.func.body;
  } else {
    head = procedure->value.proc.head;
    storage = procedure->value.proc.storage;
    body = procedure->value.proc.body;
  }

  if (storage == storage_extern)
    return;

  assert(head->tag == node_head);  
  assert(body->tag == node_body); 
  name = head->value.head.name;
  args = head->value.head.args;
  decl = body->value.body.decl;
  statements = body->value.body.statements; 

  if (is_func) {
    fprintf(state.output.f, "; function %s\n", name);
  } else {
    fprintf(state.output.f, "; procedure %s\n", name);
  }

  /* data memory section */
  if ((args != NULL) || (decl != NULL)) {
    fprintf(state.output.f, ".udata_%s udata\n", name);
    /* the procedure or function has arguments */ 
    if (args != NULL) {
      assert(args->tag == node_list);
      for (; args; args = LIST_TAIL(args)) {
        argument = LIST_HEAD(args);
        assert(argument->tag == node_decl);
        assert(argument->value.decl.type == 0);
        /* FIXME: only bytes are supported so far */
        assert(argument->value.decl.size == size_byte);
        write_decl(argument, name);
      }  
    }
    /* the procedure or function has local variables */ 
    if (decl != NULL) {
      assert(decl->tag == node_list);
      for (; decl; decl = LIST_TAIL(decl)) {
        argument = LIST_HEAD(decl);
        assert(argument->tag == node_decl);
        /* FIXME: only bytes are supported so far */
        assert(argument->value.decl.size == size_byte);
        if (argument->value.decl.type == type_var)
          write_decl(argument, name);

      }  
    }
    
    fprintf(state.output.f, "\n");
  }

  /* program memory section */
  fprintf(state.output.f, ".code_%s code\n", name);
  add_global(name, name, procedure);
  write_label(name);
  if (storage == storage_public)
    fprintf(state.output.f, "  global %s\n", name);
  max_temp_number = 0;
  write_statements(statements);
  fprintf(state.output.f, "  return\n");
  fprintf(state.output.f, "\n");

  /* temp data section */
  if (max_temp_number) {
    /* FIXME: overlay this if possible */
    fprintf(state.output.f, ".udata_%s_temp udata\n", name);
    for(i = 0; i < max_temp_number; i++)
      fprintf(state.output.f, "_temp_%d res 1\n", i);
      
    fprintf(state.output.f, "\n");
  }

}

static void
extern_name(char *name1, char *name2, tree *symbol)
{
  char buffer[BUFSIZ];

  if (name2)
    sprintf(buffer, "%s_%s", name1, name2);
  else
    sprintf(buffer, "%s", name1);

  fprintf(state.output.f, "  extern %s\n", buffer);
  add_global(buffer, buffer, symbol);

  return;
}

static void
extern_args(char *main_name, tree *list)
{
  tree *decl;
  tree *symbol;

  while (list) {
    decl = LIST_HEAD(list);
    assert(decl->tag == node_decl);
    symbol = decl->value.decl.expr;
    assert(symbol->tag == node_symbol);
    extern_name(main_name, symbol->value.symbol, symbol);
    list = LIST_TAIL(list);
  }

}

static enum node_storage
determine_storage(tree *node)
{
  enum node_storage storage;

  switch(node->tag) {
  case node_decl:
    storage = DECL_STOR(node);
    break;
  case node_decl_prot:
    storage = DECL_PROT_STOR(node);
    break;
  case node_func:
    storage = FUNC_STOR(node);
    break;
  case node_func_prot:
    storage = FUNC_PROT_STOR(node);
    break; 
  case node_proc:
    storage = PROC_STOR(node);
    break;
  case node_proc_prot:
    storage = PROC_PROT_STOR(node);
    break;
  default:
    assert(0);
  }   

  return storage;
}

static void
write_externs(void)
{
  tree *current = NULL;
  char *name;
  tree *args = NULL;
  tree *symbol = NULL;
  gp_boolean first_time = true;

  current = state.root;
  while (current != NULL) {
    if (determine_storage(current) == storage_extern) {
      if (first_time == true)  {
        fprintf(state.output.f, "; external symbols\n");
        first_time = false;
      }
      switch(current->tag) {
      case node_decl_prot:
        symbol = LIST_HEAD(current->value.decl.expr);
        extern_name(symbol->value.symbol, NULL, symbol);
        break;
      case node_func_prot:
        name = current->value.func.head->value.head.name;
        args = current->value.func.head->value.head.args;
        extern_name(name, NULL, current);
        extern_args(name, args);
        break; 
      case node_proc_prot:
        name = current->value.proc.head->value.head.name;
        args = current->value.proc.head->value.head.args;
        extern_name(name, NULL, current);
        extern_args(name, args);
        break;
      case node_decl:
      case node_func:
      case node_proc:
      default:
        assert(0);
      }
    }
    current = current->next;
  }

  if (first_time == false)
    fprintf(state.output.f, "\n");

  return;
}

static char *
find_node_name(tree *node)
{
  tree *symbol;
  tree *head;
  char *name = NULL;

  switch(node->tag) {
  case node_decl:
    symbol = LIST_HEAD(DECL_EXPR(node));
    assert(symbol->tag == node_symbol);
    name = symbol->value.symbol;
    break;
  case node_decl_prot:
    symbol = LIST_HEAD(DECL_PROT_EXPR(node));
    assert(symbol->tag == node_symbol);
    name = symbol->value.symbol;
    break;
  case node_func:
    head = FUNC_HEAD(node);
    name = HEAD_NAME(head);
    break;
  case node_func_prot:
    head = FUNC_PROT_HEAD(node);
    name = HEAD_NAME(head);
    break; 
  case node_proc:
    head = PROC_HEAD(node);
    name = HEAD_NAME(head);
    break;
  case node_proc_prot:
    head = PROC_PROT_HEAD(node);
    name = HEAD_NAME(head);
    break;
  default:
    assert(0);
  }   

  return name;
}

static tree *
find_node(char *name, enum node_tag tag)
{
  tree *current = NULL;
  tree *found = NULL;
  char *node_name;

  current = state.root;
  while (current != NULL) {
    if (current->tag == tag) {
      node_name = find_node_name(current);
      if (strcasecmp(node_name, name) == 0) {
        found = current;
        break;
      }
    }
    current = current->next;
  }

  return found;
}

static void
remove_public_prots(void)
{
  tree *current = NULL;
  tree *def;
  gp_boolean remove_prot;

  /* FIXME: need to check that the prototype matches the function */

  /* remove the public prototypes */
  current = state.root;
  while (current != NULL) {
    remove_prot = false;
    if (determine_storage(current) == storage_public) {
      switch(current->tag) {
      case node_decl:
      case node_func:
      case node_proc:
        /* do nothing */
        break;
      case node_decl_prot:
        def = find_node(find_node_name(current), node_decl);
        DECL_STOR(def) = storage_public;
        remove_prot = true;
        break;
      case node_func_prot:
        def = find_node(find_node_name(current), node_func);
        FUNC_STOR(def) = storage_public;
        remove_prot = true;
        break; 
      case node_proc_prot:
        def = find_node(find_node_name(current), node_proc);
        PROC_STOR(def) = storage_public;
        remove_prot = true;
        break;
      default:
        break;
      }
      if (remove_prot) {
         if (current->prev == NULL ) {
           state.root = current->next;
         } else {
           current->prev->next = current->next;      
         }
      }
    }	

    current = current->next;
  }  

}

void
write_asm(void)
{
  tree *current = NULL;

  remove_public_prots();

  write_header();
  write_startup();
  write_declarations();
  write_externs();

  /* write out all the source */
  current = state.root;
  while (current != NULL) {
    switch(current->tag) {
    case node_decl:
    case node_decl_prot:
    case node_func_prot:
    case node_proc_prot:
      /* do nothing */
      break;
    case node_func:
      write_procedure(current, 1);
      break; 
    case node_proc:
      write_procedure(current, 0);
      break;
    default:
      assert(0);
    }
    current = current->next;
  }

  write_footer();  
}
